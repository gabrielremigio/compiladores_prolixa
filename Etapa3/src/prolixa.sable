Package prolixa;

Helpers
    all = [0 .. 0xFFFF];    /* Qualquer caractere da tabela ASCII */
    lowercase = ['a' ..'z'];
    uppercase = ['A' ..'Z'];
    digito = ['0' .. '9'];
    digito_hexa = [digito + [['a' .. 'f'] + ['A' .. 'F']]];

    numero_real = (digito)+ '.' (digito)+;

    espaco = ' ';
    aspa_simples = 39;
    aspa_dupla = 34;
    chave_dir_ascii = 123;
    chave_esq_ascii = 125;
    tab = 9;
    rc = 13;
    nl = 10;
    eol = rc nl | rc | nl;
    blank = (eol | tab | espaco)+;

    all_sem_chave = [all - chave_esq_ascii];

    all_sem_aspas = [all - [aspa_dupla + aspa_simples]];

    comment = '{' all_sem_chave* '}'; /* regra de comentário ainda está inválida de acordo com os padrões de c, verificar o docs de testes para ver quais casos são inválidos. */

    letra = lowercase | uppercase | '_' ;

    id = uppercase (letra)*;

Tokens

    this = 'This';
    is = 'is';
    program = 'program';
    it = 'It';
    presents = 'presents';
    let = 'Let';
    us = 'us';
    begin = 'begin';
    would = 'would';
    be = 'be';
    all = 'all';
    unalterable = 'unalterable';
    alterable = 'alterable';
    symbol = 'symbol';
    number = 'number';
    answer = 'answer';
    answer_values = 'yes' | 'no';
    just = 'just';
    in  = 'in';
    case = 'case';
    that = 'that';
    otherwise = 'otherwise';
    as = 'as';
    long = 'long';
    do = 'do';
    considering = 'considering';
    that1 = 'that';
    that2 = 'That';
    from = 'from';
    by = 'by';
    show = 'show';
    capture = 'capture';
    abandon = 'abandon';
    go = 'go';
    to = 'to';
    next = 'next';
    iteration = 'iteration';
    vetor = 'vector';
    of = 'of';

    x = 'x';

    identificador = id ;

    constante = 'unalterable' id;
    variavel = 'alterable' id;

    semicolon = ';';
    colon = ',';
    dot = '.';
    d_dot = ':';
    aspa_simples = aspa_simples;
    aspa_dupla = aspa_dupla;

    p_esq = '(';
    p_dir = ')';
    c_esq = '[';
    c_dir = ']';

    vincula = '=';
    atribui = ':=';
    
    mais = '+';
    menos = '-';
    estrela = '*';
    div = '/';
    div_int = '//';

    eq = '==';
    neq = '!=';
    lt = '<';
    lteq = '<=';
    gt = '>';
    gteq = '>=';

    exclamacao = '!';
    and = 'and';
    or = 'or';
    xor = 'xor';

    numero = ('-')? (digito)+ | ('-')? (numero_real)+;
    string = aspa_dupla all_sem_aspas* aspa_dupla;
    symbol_values = aspa_simples all_sem_aspas* aspa_simples;

    blank = blank;
    comment = comment;

Ignored Tokens
    blank, comment;

Productions
    
    start = 
        {Programa_Start} programa;

    programa = 
        {Programa} this is program identificador dot declaracoes comandos;

    delcaracoes = 
        {Declaracoes} it presents d_dot declaracao+;

    comandos = 
        {Comandos} let us begin d_dot comando+ that2 would be all dot;

    declaracao = 
        {Alterable_declaracao} alterable tipo identificador semicolon |
        {Unalterable_declaracao} unalterable tipo identificador [vincula valor] semicolon |
        {Vector_declaracao} vector of tipo p_dir exp { x exp } p_esq identificador semicolon;

    tipo = 
        {Numero_tipo} 'numero' |
        {Answer_tipo} 'answer' |
        {Symbol_tipo} 'symbol';

    var = 
        {Identificador_var1} identificador |
        {Identificador_var2} identificador p_dir exp { colon exp } p_esq;
    
    unalt = 
        {Identificador_unalt} identificador;

    valor = 
        {Symbol_valor} symbol_values |
        {Numero_valor} numero |
        {Answer_valor} answer_values |
        {String_valor} string;
    
    comando =
        {Var_comando} var atribui exp semicolon |
        {Unalt_comando} unalt vincula exp semicolon |
        {Capture} capture p_dir { var colon } var p_esq semicolon |
        {Show} show p_dir { exp colon } exp p_esq semicolon |
        {Just in case} just in case that1 p_dir exp p_esq do comando [otherwise comando] |
        {As long as} as long as p_dir exp p_esq do comando |
        {Considering} considering var from exp to exp by exp do comando |
        {Abadon} abandon semicolon |
        {Goto} go to next iteration semicolon |
        {Bloco} bloco;

    bloco = 
        {Bloco de comando} c_dir {declaracao} {comando} c_esq;

    exp = 
        {Valor_exp} valor |
        {Var_exp} var |
        {Exp1} p_dir exp p_esq |
        {Exp2} menos exp |
        {Exp3} exp mais exp |
        {Exp4} exp menos exp |
        {Exp5} exp estrela exp |
        {Exp6} exp div exp |
        {Exp7} exp div_int exp |
        {Exp8} exp eq exp |
        {Exp9} exp neq exp |
        {Exp10} exp lteq exp |
        {Exp11} exp gteq exp |
        {Exp12} exp lt exp |
        {Exp13} exp gt exp |
        {Exp14} exp and exp |
        {Exp15} exp or exp |
        {Exp16} exp xor exp |
        {Exp17} exclamacao exp; 